# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14LKaiCqAEo2iLev_xW8TAfvPpsjdfu4C

1. What are data structures, and why are they important?
-  Data structures are ways of organizing and storing data in a computer so that it can be accessed and modified efficiently. They are important because they allow us to manage and manipulate data in a way that is suitable for various tasks and problems, which in turn helps in writing efficient and optimized code

2.  Explain the difference between mutable and immutable data types with examples?
-  Mutable data types are those whose values can be changed after they are created. This means you can modify, add, or remove elements from them. Examples of mutable data types in Python include lists, dictionaries, and sets.

3. What are the main differences between lists and tuples in Python?
-  The main differences between lists and tuples in Python are:

Mutability: Lists are mutable, meaning you can change their elements after creation. Tuples are immutable, meaning their elements cannot be changed after creation.

Syntax: Lists are defined using square brackets [], while tuples are defined using parentheses ().

Performance: Tuples are generally faster than lists because of their immutable nature. Since their size is fixed, Python can perform some optimizations.

Use cases: Lists are typically used for collections of items that might change, while tuples are used for collections of items that should not change, such as coordinates or database records.

4.  Describe how dictionaries store data?
-  Dictionaries in Python store data as key-value pairs. Think of it like a real-world dictionary where you look up a word (the key) to find its definition (the value).

5. Why might you use a set instead of a list in Python?
-  You might choose to use a set instead of a list in Python for several reasons, primarily related to the unique nature of set elements and their performance characteristics for certain operations:

6. What is a string in Python, and how is it different from a list?
-  In Python, a string is a sequence of characters. It's used to represent text. Strings are immutable, meaning once you create a string, you cannot change individual characters within it. Any operation that seems to modify a string actually creates a new string. Strings are enclosed in single quotes ('...'), double quotes ("..."), or triple quotes ('''...''' or '''...''') for multi-line strings.

7. How do tuples ensure data integrity in Python?
-  Tuples ensure data integrity in Python primarily through their immutability. Because you cannot change the elements of a tuple after it's created, you can be confident that the data within the tuple will remain exactly as it was when the tuple was defined.

8. What is a hash table, and how does it relate to dictionaries in Python?
-  A hash table (also known as a hash map or dictionary) is a data structure that implements an associative array, which is a collection of key-value pairs. It uses a hash function to compute an index into an array of buckets or slots, from which the desired value can be found
ython dictionaries are implemented using hash tables. This means that:

When you create a dictionary and add key-value pairs, Python uses a hash function to determine where to store each pair based on the key.
When you access a value using a key (e.g., my_dict["name"]), Python calculates the hash of the key and uses it to quickly locate the corresponding value in the hash table.

9.  Can lists contain different data types in Python?
-  es, absolutely! Lists in Python are incredibly flexible and can contain elements of different data types within the same list. This is a key feature that makes lists very versatile.

10.  Explain why strings are immutable in Python?
-  Strings are immutable in Python, meaning once a string object is created, its contents cannot be changed. While this might seem like a limitation at first, there are several reasons why Python's designers chose to make strings immutable:

11. What advantages do dictionaries offer over lists for certain tasks?
-  Fast Lookups (Retrieval by Key): This is arguably the biggest advantage. Accessing a value in a dictionary by its key is extremely fast, on average O(1) (constant time), regardless of the size of the dictionary. This is because dictionaries use hash tables, which allow for direct access to the value based on the key's hash. In contrast, finding a specific element in a list by its value requires iterating through the list, which can take O(n) time (linear time) in the worst case.


Meaningful Indexing: Dictionaries use descriptive keys (like strings) to access values, rather than numerical indices (like in lists). This makes your code more readable and understandable, as the key itself conveys the meaning of the data you are accessing. For example, person["name"] is much more descriptive than person[0].


Representing Relationships: Dictionaries are excellent for representing relationships between pieces of data where one piece of data (the key) is uniquely associated with another (the value). This is ideal for things like configuration settings, object properties, or mapping identifiers to objects.


Storing Unordered Collections of Unique Keys: While lists are ordered collections where elements are accessed by their position, dictionaries store an unordered collection of unique keys with associated values. This is useful when the order of items doesn't matter, but you need quick access to values based on their unique identifiers.


Flexibility in Data Types: Both keys and values in dictionaries can be of various data types (with keys having the hashability constraint). This allows for flexible data representation.

12. Describe a scenario where using a tuple would be preferable over a list?
-  A scenario where using a tuple would be preferable over a list is when you need to represent a collection of related items that should not be changed after they are created.

Here are a few specific examples:

Representing Coordinates: If you are working with geometric shapes or plotting, you might need to represent points in a 2D or 3D space. A coordinate like (x, y) or (x, y, z) is a fixed set of values that shouldn't typically be altered. Using a tuple (x, y) ensures that these coordinates remain constant.


Storing RGB Color Values: Color can be represented using a combination of red, green, and blue values. An RGB color value, like (255, 0, 0) for red, is a fixed set of three numbers. Using a tuple (red, green, blue) ensures that these color components aren't accidentally modified.


Returning Multiple Values from a Function: Functions in Python can return multiple values, and they are typically returned as a tuple. This is a clean and efficient way to package related data that should remain together and unchanged as a single result.

13. How do sets handle duplicate values in Python?
-  Sets in Python are designed to store unique and unordered elements. This means that sets automatically handle duplicate values by discarding them.

14. How does the “in” keyword work differently for lists and dictionaries?
-  The in keyword in Python is used to test for membership, but it behaves differently for lists and dictionaries due to their underlying structure and how they store data.

For Lists:

When you use in with a list, it checks if an element is present anywhere within the list. Python iterates through the list from the beginning and compares each element to the one you're searching for

For Dictionaries:

When you use in with a dictionary, it checks if a key is present in the dictionary. It does not check if a value is present. Python uses the dictionary's hash table structure to quickly determine if the key exists.

15. Can you modify the elements of a tuple? Explain why or why not?
-  No, you cannot modify the elements of a tuple after it has been created.

The reason for this is that tuples are immutable data types in Python. Immutability means that the contents of the object cannot be changed after it is created. Once a tuple is defined, its size and the values of its elements are fixed.

Any operation that appears to modify a tuple, such as trying to assign a new value to an element by index, will result in a TypeError.

16. What is a nested dictionary, and give an example of its use case?
-  A nested dictionary in Python is simply a dictionary where at least one of the values is another dictionary. This allows you to create hierarchical data structures, representing more complex relationships between data.
Use Case Example:

A common use case for nested dictionaries is representing structured data like JSON (JavaScript Object Notation), which is frequently used for data exchange on the web. A JSON object often translates directly into a nested dictionary in Python.

17. Describe the time complexity of accessing elements in a dictionary?
-  The time complexity of accessing elements in a Python dictionary (retrieving a value using its key) is, on average, O(1) (constant time).

This means that the time it takes to access an element is generally independent of the number of elements in the dictionary. Whether the dictionary has 10 items or 1 million items, the time to retrieve a value by its key is roughly the same.

This efficiency is a major advantage of dictionaries and is achieved because of their underlying implementation using hash tables.

Here's why it's O(1) on average:

Hashing: When you access a value using a key, Python's hash function calculates a hash value for the key.
Direct Access: This hash value is then used to directly calculate the index (or location) in the hash table where the corresponding value is stored.

18. In what situations are lists preferred over dictionaries?
-  Both lists and dictionaries are powerful data structures in Python — but they’re used in different situations depending on what kind of data you’re handling and how you want to access it.

19.  Why are dictionaries considered unordered, and how does that affect data retrieval?
-  Historically, in Python versions prior to 3.7, dictionaries were considered unordered. This meant that the order in which you inserted key-value pairs into a dictionary was not guaranteed to be the order in which they were stored or retrieved. The internal implementation of dictionaries using hash tables determined the storage order, which was not based on insertion orde

20. Explain the difference between a list and a dictionary in terms of data retrieval.
-  The main difference between a list and a dictionary in terms of data retrieval lies in how you access the individual elements or values.

Data Retrieval in Lists:

Method: Data in lists is retrieved by its numerical index (its position in the sequence). Indices start at 0 for the first element.
Mechanism: When you access an element by index, Python goes directly to that position in the list's underlying memory structure.
Time Complexity: Accessing an element by index in a list is typically a fast operation, with a time complexity of O(1) on average.
Search by Value: If you need to find an element in a list based on its value, you would typically use the in operator or the list.index() method. This involves iterating through the list, which has a time complexity of O(n) in the worst case.


Data Retrieval in dictionaries:
Method: Data in dictionaries is retrieved by its key. Each value is associated with a unique key.
Mechanism: When you access a value using its key, Python uses a hash function to quickly locate the key's position in the dictionary's hash table.
Time Complexity: Retrieving a value by its key in a dictionary is very efficient, with an average time complexity of O(1). This is significantly faster than searching for a value in a list.
Search by Key: The in operator is used to efficiently check if a key exists in the dictionary, with an average time complexity of O(1).
"""

# Write a code to create a string with your name and print it

my_name = "abhimanyu"
print(my_name)

# Write a code to find the length of the string "Hello World"

my_string = "Hello World"
string_length = len(my_string)
print(string_length)

# Write a code to slice the first 3 characters from the string "Python Programming"

my_string = "Python Programming"
first_three = my_string[:3]
print(first_three)

# Write a code to convert the string "hello" to uppercase

my_string = "hello"
uppercase_string = my_string.upper()
print(uppercase_string)

# Write a code to replace the word "apple" with "orange" in the string "I like apple"

my_string = "I like apple"
new_string = my_string.replace("apple", "orange")
print(new_string)

# Write a code to create a list with numbers 1 to 5 and print it

my_list = [1, 2, 3, 4, 5]
print(my_list)

# Write a code to append the number 10 to the list [1, 2, 3, 4]

my_list = [1, 2, 3, 4]
my_list.append(10)
print(my_list)

# Write a code to remove the number 3 from the list [1, 2, 3, 4, 5]

my_list = [1, 2, 3, 4, 5]
my_list.remove(3)
print(my_list)

# Write a code to access the second element in the list ['a', 'b', 'c', 'd']

my_list = ['a', 'b', 'c', 'd']
second_element = my_list[1]
print(second_element)

# Write a code to reverse the list [10, 20, 30, 40, 50].

my_list = [10, 20, 30, 40, 50]
reversed_list = my_list[::-1]
print(reversed_list)

# Write a code to create a tuple with the elements 100, 200, 300 and print it

my_tuple = (100, 200, 300)
print(my_tuple)

# Write a code to access the second-to-last element of the tuple ('red', 'green', 'blue', 'yellow')

my_tuple = ('red', 'green', 'blue', 'yellow')
second_to_last_element = my_tuple[-2]
print(second_to_last_element)

# Write a code to find the minimum number in the tuple (10, 20, 5, 15).

my_tuple = (10, 20, 5, 15)
minimum_number = min(my_tuple)
print(minimum_number)

# Write a code to find the index of the element "cat" in the tuple ('dog', 'cat', 'rabbit').

my_tuple = ('dog', 'cat', 'rabbit')
index_of_cat = my_tuple.index("cat")
print(index_of_cat)

#  Write a code to create a tuple containing three different fruits and check if "kiwi" is in it.

fruits_tuple = ("apple", "banana", "orange")
is_kiwi_in_tuple = "kiwi" in fruits_tuple
print(is_kiwi_in_tuple)

# Write a code to create a set with the elements 'a', 'b', 'c' and print it.

my_set = {'a', 'b', 'c'}
print(my_set)

# Write a code to clear all elements from the set {1, 2, 3, 4, 5}.

my_set = {1, 2, 3, 4, 5}
my_set.clear()
print(my_set)

# Write a code to remove the element 4 from the set {1, 2, 3, 4}.

my_set = {1, 2, 3, 4}
my_set.remove(4)
print(my_set)

# Write a code to find the union of two sets {1, 2, 3} and {3, 4, 5}.

set1 = {1, 2, 3}
set2 = {3, 4, 5}
union_set = set1 | set2
print(union_set)

# Write a code to find the intersection of two sets {1, 2, 3} and {2, 3, 4}.

set1 = {1, 2, 3}
set2 = {2, 3, 4}
intersection_set = set1 & set2
print(intersection_set)

# Write a code to create a dictionary with the keys "name", "age", and "city", and print it.

my_dict = {
    "name": "Abhimanyu",
    "age": 21,
    "city": "india"
}
print(my_dict)

# Write a code to add a new key-value pair "country": "USA" to the dictionary {'name': 'John', 'age': 25}.

my_dict = {'name': 'John', 'age': 25}
my_dict["country"] = "USA"
print(my_dict)

# Write a code to access the value associated with the key "name" in the dictionary {'name': 'Alice', 'age': 30}.

my_dict = {'name': 'Alice', 'age': 30}
name_value = my_dict["name"]
print(name_value)

# Write a code to remove the key "age" from the dictionary {'name': 'Bob', 'age': 22, 'city': 'New York'}.

my_dict = {'name': 'Bob', 'age': 22, 'city': 'New York'}
del my_dict["age"]
print(my_dict)

# Write a code to check if the key "city" exists in the dictionary {'name': 'Alice', 'city': 'Paris'}.

my_dict = {'name': 'Alice', 'city': 'Paris'}
key_exists = "city" in my_dict
print(key_exists)

# Write a code to create a list, a tuple, and a dictionary, and print them all.

# Create a list
my_list = [1, 2, 3, 4, 5]

# Create a tuple
my_tuple = ('a', 'b', 'c')

# Create a dictionary
my_dict = {
    "name": "Alice",
    "age": 30,
    "city": "New York"
}

# Print all of them
print("My List:", my_list)
print("My Tuple:", my_tuple)
print("My Dictionary:", my_dict)

# Write a code to create a list of 5 random numbers between 1 and 100, sort it in ascending order, and print the result.(replaced)

random_numbers = [random.randint(1, 100) for _ in range(5)]
random_numbers.sort()

print(random_numbers)

# Write a code to create a list with strings and print the element at the third index.

my_string_list = ["apple", "banana", "cherry", "date", "elderberry"]
third_element = my_string_list[3]
print(third_element)

#  Write a code to combine two dictionaries into one and print the result.

dict1 = {"a": 1, "b": 2}
dict2 = {"c": 3, "d": 4}

combined_dict = {**dict1, **dict2}

print(combined_dict)

# Write a code to convert a list of strings into a set

my_list_of_strings = ["apple", "banana", "apple", "orange", "banana"]
my_set_of_strings = set(my_list_of_strings)
print(my_set_of_strings)

